<!-- ?xml version='1.0' encoding='UTF-8'? -->
<link href="github-css.css" rel="stylesheet"/>
<meta charset="utf-8" content="text/html"/>
<div class="gist">
<style> .gist-file { max-width: 25cm; margin: 0 auto; } </style>
<style class="formula-style">
        svg.gh-md-to-html-formula {
            fill: black;
        }
    </style>
<div class="gist-file"> <!-- This is the class that is responsible for the boxing! -->
<div class="gist-data">
<div class="js-gist-file-update-container js-task-list-container file-box">
<div class="file" id="user-content-article-tempfile">
<div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="user-content-file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px">
<article class="markdown-body entry-content container-lg" itemprop="text">
<div class="markdown-heading"><h1 class="heading-element">Apple IIgs Object Module Format (OMF)</h1><a aria-label="Permalink: Apple IIgs Object Module Format (OMF)" class="anchor" href="#user-content-apple-iigs-object-module-format-omf" id="user-content-apple-iigs-object-module-format-omf" name="user-content-apple-iigs-object-module-format-omf"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>File types:</p>
<ul>
<li>ProDOS OBJ, LIB, S16, RTL, EXE, PIF, TIF, NDA, CDA, TOL, DVR, LDF, FST</li>
</ul>
<p>Primary references:</p>
<ul>
<li>
<em>ORCA/M: A Macro Assembler for the Apple IIgs</em> (ORCA/M 2.0 manual); appendix B documents
OMF v0, v1, and v2.1 files (see p.488)</li>
<li>
<em>Apple IIgs Programmer's Workshop Reference</em>; chapter 7 describes OMF v1.0 and v2.0 (see p.228)</li>
<li>
<em>Apple IIgs GS/OS Reference, for GS/OS System Software Version 5.0 and later</em>; Appendix F
describes OMF v2.1, and Chapter 8 has some useful information about how the loader works
(e.g. p.205)</li>
<li>"Undocumented Secrets of the Apple IIGS System Loader" web page by Neil Parker,
<a href="http://nparker.llx.com/a2/loader.html" rel="nofollow">http://nparker.llx.com/a2/loader.html</a>; documents ExpressLoad segments and other arcana</li>
<li>6502bench SourceGen OMF converter; acts as a loader to prepare load files for disassembly:
<a href="https://github.com/fadden/6502bench/blob/master/SourceGen/Tools/Omf/">https://github.com/fadden/6502bench/blob/master/SourceGen/Tools/Omf/</a>
</li>
</ul>
<div class="markdown-heading"><h2 class="heading-element">General</h2><a aria-label="Permalink: General" class="anchor" href="#user-content-general" id="user-content-general" name="user-content-general"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>Object Module Format defines a way to package executable code and data.  It was developed by
ByteWorks for its assembler and compiler products (e.g. ORCA/M), and licensed by Apple for GS/OS
and the Apple IIgs Programmer's Workshop (APW).  OMF can be used for four kinds of files:</p>
<ol>
<li>Object files.  The output of an assembler or compiler is stored in these.  They may
contain unresolved references, and must be processed by a linker before they can be run.
(ProDOS type OBJ.)</li>
<li>Library files.  These contain a number of pieces that are extracted by the linker and
added to an object file while it is built.  (ProDOS type LIB.)</li>
<li>Load files.  These are executable programs generated by a linker, from object files and
library files.  The system loader will read them into memory and process relocations.
(ProDOS types S16, EXE, PIF, TIF, NDA, CDA, TOL, DVR, LDF, FST.)</li>
<li>Run-time library files.  Defined by the OMF specification but not implemented by the
loader?  (ProDOS type RTL.)</li>
</ol>
<p>OMF files don't have an indication of which kind they are.  They are simply a series of segments,
and it's up to the program reading them to decide how they should be handled.  OMF v1 defines
a key field differently for load files and library files (BLKCNT / BYTECNT), so it's not always
possible to parse OMF correctly without knowing the ProDOS file type (or making educated guesses).</p>
<p>There are four versions of OMF:</p>
<ul>
<li>v0.0: original 8-bit Orca/M format.  0x24 bytes followed by variable-length SEGNAME.</li>
<li>v1.0: initial Apple IIgs format.  Adds LCBANK, SEGNUM, ENTRY, DISPNAME, DISPDATA, and
LOADNAME.  Introduces BLKCNT/BYTECNT ambiguity.</li>
<li>v2.0: updated Apple IIgs format.  Removes LCBANK, redefines TYPE/KIND, and removes parsing
ambiguity by embracing BYTECNT.</li>
<li>v2.1: adds TEMPORG and some attribute flags.</li>
</ul>
<div class="markdown-heading"><h2 class="heading-element">File Format</h2><a aria-label="Permalink: File Format" class="anchor" href="#user-content-file-format" id="user-content-file-format" name="user-content-file-format"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>Each file is a series of segments.  Each segment has a header and a body; the body is a series
of records.</p>
<p>The original "version 0" header, used by older 8-bit ORCA/M, is:</p>
<pre><code>+$00 / 4: BLOCKCCOUNT: length of segment in file, in 512-byte blocks
+$04 / 4: RESSPC: number of bytes of zeroes to add to the end of the segment
+$08 / 4: LENGTH: memory size required by segment when loaded; includes RESSPC
+$0c / 1: TYPE: enumerations and flags; bits 0-4 determine the segment type (code, data, etc.)
+$0d / 1: LABLEN: length of names in label records, or 0 if strings are prefixed with length
+$0e / 1: NUMLEN: length of numbers in segment body (must be 4)
+$0f / 1: VERSION: OMF version (0 for v0.0)
+$10 / 4: BANKSIZE: maximum memory bank size for segment
+$14 / 4: ORG: absolute address at which segment is to be loaded
+$18 / 4: ALIGN: boundary on which this segment must be aligned
+$1c / 1: NUMSEX: order of bytes, 0 for little-endian, 1 for big-endian (must be 0)
+$1d / 7: (reserved)
+$24 / nn: SEGNAME: segment name; string length specified by LABLEN
</code></pre>
<p>The v1.0 header is:</p>
<pre><code>+$00 / 4: BLKCNT / BYTECNT: length of segment in file, either as 512-byte blocks or bytes
+$04 / 4: RESSPC: number of bytes of zeroes to add to the end of the segment
+$08 / 4: LENGTH: memory size required by segment when loaded; includes RESSPC
+$0c / 1: TYPE: enumerations and flags; bits 0-4 determine the segment type (code, data, etc.)
+$0d / 1: LABLEN: length of names in label records, or 0 if strings are prefixed with length
+$0e / 1: NUMLEN: length of numbers in segment body (must be 4)
+$0f / 1: VERSION: OMF version (1 for v1.0)
+$10 / 4: BANKSIZE: maximum memory bank size for segment
+$14 / 4: (reserved)
+$18 / 4: ORG: absolute address at which segment is to be loaded
+$1c / 4: ALIGN: boundary on which this segment must be aligned
+$20 / 1: NUMSEX: order of bytes, 0 for little-endian, 1 for big-endian (must be 0)
+$21 / 1: LCBANK: indicates the language card bank into which the segment should be loaded
+$22 / 2: SEGNUM: segment number
+$24 / 4: ENTRY: offset into the segment of the entry point
+$28 / 2: DISPNAME: displacement (offset) of the LOADNAME field
+$2a / 2: DISPDATA: displacement (offset) of the segment body
+DISPNAME / 10: LOADNAME: target segment for linker; padded with spaces to fill out 10 bytes
++$0a / nn: SEGNAME: segment name; string length specified by LABLEN
</code></pre>
<p>The TYPE field is mis-labeled KIND in early APW documentation.</p>
<p>The v2.0 header is:</p>
<pre><code>+$00 / 4: BYTECNT: number of bytes in the file that the segment requires, including the header
+$04 / 4: RESSPC: number of bytes of zeroes to add to the end of the segment
+$08 / 4: LENGTH: memory size required by segment when loaded; includes RESSPC
+$0c / 1: (reserved)
+$0d / 1: LABLEN: length of names in label records, or 0 if strings are prefixed with length
+$0e / 1: NUMLEN: length of numbers in segment body (must be 4)
+$0f / 1: VERSION: OMF version (2 for v2.x)
+$10 / 4: BANKSIZE: maximum memory bank size for segment
+$14 / 2: KIND: enumerations and flags that define segment attributes
+$16 / 2: (reserved)
+$18 / 4: ORG: absolute address at which segment is to be loaded
+$1c / 4: ALIGN: boundary on which this segment must be aligned
+$20 / 1: NUMSEX: order of bytes, 0 for little-endian, 1 for big-endian (must be 0)
+$21 / 1: (reserved)
+$22 / 2: SEGNUM: segment number
+$24 / 4: ENTRY: offset into the segment of the entry point
+$28 / 2: DISPNAME: displacement (offset) of the LOADNAME field
+$2a / 2: DISPDATA: displacement (offset) of the segment body
+DISPNAME / 10: LOADNAME: target segment for linker; padded with spaces to fill out 10 bytes
++$0a / nn: SEGNAME: segment name; string length specified by LABLEN
</code></pre>
<p>Version 2.1 adds a 4-byte field at +$2A called "tempOrg", and defines some new KIND flags.  The
"temporary origin" field is used by the MPW IIgs cross-assembler.</p>
<p>Versions 0 and 1 aligned segments at 512-byte boundaries.  The file length was generally also
a multiple of 512.</p>
<p>The GS/OS reference declares that an OMF file is "foreign" unless:</p>
<ul>
<li>NUMSEX field is 0</li>
<li>NUMLEN field is 4</li>
<li>BANKSIZE field is &lt;= $10000</li>
<li>ALIGN field is &lt;= $10000</li>
</ul>
<p>There are a couple of bugs in the GS/OS documentation:</p>
<ul>
<li>GS/OS ref: table F-2 says "blockCount" where it should say "SEGNAME", and shows the
offset of "tempOrg" as $2a (should be $2c).</li>
<li>GS/OS ref: appendix F refers to a "REVISION" field, which does not seem to exist.</li>
</ul>
<p>The defined segment types, specified by the low 5 bits of the TYPE/KIND field, are:</p>
<pre><code> $00: code
 $01: data
 $02: jump table
 $04: pathname
 $08: library dictionary
 $10: initialization
 $11: absolute bank (v1.0 only; became a flag in v2.0)
 $12: DP/Stack
</code></pre>
<div class="markdown-heading"><h3 class="heading-element">Segment Body</h3><a aria-label="Permalink: Segment Body" class="anchor" href="#user-content-segment-body" id="user-content-segment-body" name="user-content-segment-body"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>The segment body is a series of records.  Records start with an opcode byte, which can fall
into three categories:</p>
<ul>
<li>$00: indicates the end of the segment</li>
<li>$01-df: count of the number of bytes that follow; these are copied directly at load time</li>
<li>$e0-ff: directives</li>
</ul>
<p>Directives can be constants, relocation records, expressions, and so on.</p>
<div class="markdown-heading"><h3 class="heading-element">ExpressLoad</h3><a aria-label="Permalink: ExpressLoad" class="anchor" href="#user-content-expressload" id="user-content-expressload" name="user-content-expressload"><span aria-hidden="true" class="octicon octicon-link"></span></a></div>
<p>ExpressLoad was introduced in System 5 to reduce the load time of executable binaries.  It
provides an index into the segments that reduces parsing.  It can only be used with OMF v2.</p>
</article>
</div>
</div>
</div>
</div>
<div class="gist-meta">
<p><a href="../doc-index.html">Return to documentation index</a> | <a href="https://github.com/fadden/CiderPress2/blob/main/FileConv/Code/OMF-notes.md">View in source tree</a></p>
</div>
</div>
</div>
